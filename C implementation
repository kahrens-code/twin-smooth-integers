#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>

//find primes below bound
unsigned int *findSmoothPrimes(unsigned int *smoothnessBound, unsigned int *numberSmoothPrimes){
	
	unsigned int *allNumbers = (unsigned int *) calloc(*smoothnessBound, sizeof(int));
	unsigned int i; //has to be same type as *smoothnessBound
	long j; //has to be at least of size 2* *smoothnessBound +1
	unsigned int *smoothPrimes;

	for (i=1; i<*smoothnessBound; i++) {
		if (allNumbers[i] == 0) {
			allNumbers[0]++;
			for (j=(long) 2*i+1; j<*smoothnessBound; j+=i+1) {
				allNumbers[j]=1;
			}
		}
	}
	*numberSmoothPrimes = allNumbers[0];
	smoothPrimes = (unsigned int *) malloc(*numberSmoothPrimes * sizeof(int));
	j=0;
	for (i=1; i<*smoothnessBound; i++) {
		if (allNumbers[i] == 0){
			smoothPrimes[j]=i+1;
			j++;
		}
	}

	free(allNumbers);
	return smoothPrimes;
}


//prepare for powersmooth
unsigned int *findMaxExponents(unsigned int *smoothnessBound, unsigned int *numberSmoothPrimes,unsigned int *smoothPrimes){
	
	unsigned int *maxExponents = (unsigned int *) calloc(*numberSmoothPrimes, sizeof(int));
	unsigned int i;
	int j;
	
	for (i=0; i<*numberSmoothPrimes; i++) {
		j=1;
		while (pow(smoothPrimes[i],j+1)<*smoothnessBound) {
			j++;
		}
		maxExponents[i] = j;
	}

	return maxExponents;
}


//powersmooth sieve
//CAUTION: intervals with elements beyond 2^64 cause overflow and have to be tackled differently
//CAUTION: just returns an array of 0s and 1s, start value is NOT included
short *findSmoothNumbers(unsigned int *numberSmoothPrimes, unsigned int *smoothPrimes, unsigned int *maxExponents, unsigned long long *start, unsigned int *size, unsigned int *numberSmoothNumbers) {
	
	unsigned long long *interval = (unsigned long long *) malloc(*size * sizeof(long long));
	short *smoothNumbers = (short *) malloc(*size * sizeof(short));
	unsigned int i;
	unsigned int e;
	unsigned int q;
	unsigned int step;

	if (*start+*size<*start) {
		printf("Error: interval exceeds 64Bit values (findSmoothNumbers)\n");
		exit(-1);
	}
	for (i=0; i<*size; i++) {
		interval[i] = 1;
	}
	for (i=0; i<*numberSmoothPrimes; i++) {
		for (e=1; e<=maxExponents[i]; e++) {
			q = pow(smoothPrimes[i],e);
			step=q-(*start%q);
			if (step == q) {step=0;}
			while (step<*size) {
				interval[step] *= smoothPrimes[i];
				step += q;
			}
		}
	}
	*numberSmoothNumbers = 0;
	for (i=0; i<*size; i++) {
		if (*start+i == interval[i]) {
			smoothNumbers[i]=1;
			*numberSmoothNumbers+=1;
		}else{
			smoothNumbers[i]=0;
		}
	}
	
	free(interval);
	return smoothNumbers;
}

//%%%%%%%%%  check everything (paper)  %%%%%%%%%%%
unsigned long long *findSmoothIntsModC(unsigned long long *start,unsigned int *size, short *smoothNumbers, short *numberRoots, short *roots, short *deg, short *poly, unsigned int *C, unsigned int *numberSmoothIntsModC) {
	
	unsigned int *values = (unsigned int *) calloc(*size, sizeof(int));
	unsigned long long *smoothIntsModC;
	unsigned int i;
	unsigned int j;
	short maxRoot = 0;
	short smooth;
	unsigned long long eval;
	unsigned int intModC;

	for (i=1; i<*numberRoots; i++) {
		if (roots[i]>maxRoot) {
			maxRoot = roots[i];
		}
	}
	*numberSmoothIntsModC = 0;
	for (i=maxRoot; i<*size; i++) {
		if (smoothNumbers[i] == 1) {
			smooth=1;
			for (j=1; j<*numberRoots; j++) {
				if (smoothNumbers[i-roots[j]] == 0) {
					smooth=0;
					break;
				}
			}
			if (smooth ==1) {
				eval=1;
				intModC=(*start+i)%*C;
				for (j=0; j<*deg; j++) {
					eval=(eval*(intModC-poly[j]))%*C;
				}
				if (eval == 0) {
					values[*numberSmoothIntsModC]=i;
					(*numberSmoothIntsModC)++;
					printf("smooth int mod C: %llu\n", *start+i);
				}
			}
		}
	}
	smoothIntsModC= (unsigned long long *) malloc(*numberSmoothIntsModC*sizeof(long long));
	for (i=0; i<*numberSmoothIntsModC; i++) {
		smoothIntsModC[i]=values[i]+*start;
	}

	free(values);
	return smoothIntsModC;
}





//%%%%%%%%%%%%%%%%%%  check mod first (new)  %%%%%%%%%%%%%%%%%%

int cmpfnc (const void *a, const void *b) {
        return ((*(unsigned int*)a > *(unsigned int*)b)-(*(unsigned int*)a < *(unsigned int*)b));
}

unsigned int CRT (unsigned int *number, unsigned int *a, unsigned int *n, unsigned int *NN) {
	long N[*number];
	long M[*number];
	unsigned int i;
	long oldR;
	long r;
	long oldS;
	long s;
	long oldT;
	long t;
	long temp;
	long quot;
	long y=0;
	unsigned int x;

	for (i=0; i<*number; i++) {
		N[i]=*NN/n[i];
		oldR=N[i];
		r=n[i];
		oldS=1;
		s=0;
		oldT=0;
		t=1;
		while (r!=0) {
			quot = floor((double)oldR/r);
			temp = oldR;
			oldR = r;
			r = temp - quot * r;
			temp = oldS;
			oldS = s;
			s = temp - quot * s;
			temp = oldT;
			oldT = t;
			t = temp - quot * t;
		}
		//printf("Mi Ni + mi ni = %ld %ld + %ld %u = %ld\n", oldS,N[i],oldT,n[i],oldS*N[i]+oldT*n[i]);
		M[i]=oldS;
	}
	for (i=0; i<*number; i++) {
		y=(y+a[i]*M[i]*N[i])%*NN;
	}

        //printf("y: %ld\n", y);
	while (y<0) {
		y+=*NN;
          //      printf("N+y: %ld\n",y);
	}
	x=y;
	if (x>4294000000) {printf("n: %u,%u,%u, y: %ld, x:%u\n",a[0],a[1],a[2],y,x);}
        //printf("y: %ld\n", y);

	return x;
}
	



unsigned int *findResidues(unsigned int *numberSmoothPrimes, unsigned int *smoothPrimes, short *deg, short *poly, unsigned int *C, unsigned int *numberResidues) {

	unsigned int i = 0;
	unsigned int j = *C;

//factorise C	
	unsigned int factors[(unsigned int)ceil(log(*C))];
	unsigned int numberFactors = 0;
	short newFactor = 0;

	factors[0] = 1;
	while (j>1) {
		if (j % smoothPrimes[i] == 0) {
			j/=smoothPrimes[i];
			factors[numberFactors] *= smoothPrimes[i];
			newFactor = 1;
		}else {
			i++;
			if (i==*numberSmoothPrimes) {
				printf("Error: C not smooth\n");
				exit(-1);
			}
			if (newFactor==1) {
				numberFactors++;
				if (numberFactors==(unsigned int)ceil(log(*C))) {
					printf("Error: C has more than log(C) prime factors");
					exit(-1);
				}
				factors[numberFactors] = 1;
				newFactor = 0;
			}
		}
	}
	numberFactors++;
	for (i=0; i<numberFactors; i++) {
	}
	
//find residue classes such that poly(res)=0 mod C	
	unsigned int *primeResidues = (unsigned int *) calloc(*C, sizeof(int));
	unsigned int *numbersPrimeResidues = (unsigned int *) calloc(numberFactors,sizeof(int));
	unsigned int *residues;
	long long eval;
	unsigned int r=0;
	unsigned int k;
	unsigned int l;
	unsigned int nj;
	unsigned int nk;
	unsigned int nl;


	*numberResidues=1;
	for (i=0; i<numberFactors; i++) {
		for (j=0; j<factors[i]; j++) {
			eval=1;
			for (k=0; k<*deg; k++) {
				eval=(eval*((long)j-poly[k]))%(long)factors[i];
			}
			if (eval == 0) {
				primeResidues[r]=j;
				r++;
				numbersPrimeResidues[i]++;
			}
		}
		*numberResidues*=numbersPrimeResidues[i];
	}
	unsigned int *listCRT = (unsigned int *) malloc(*numberResidues * numberFactors  * sizeof(int));
	nj=1;
	nk=1;
	nl=*numberResidues;
	r=0;
	for (i=0; i<numberFactors; i++) {
		nj*=nk;
		nk=numbersPrimeResidues[i];
		nl/=nk;
		for (j=0; j<nj; j++) {
			for (k=0; k<nk; k++) {
				for (l=0; l<nl; l++) {
					*(listCRT+(nl*nk*j+nl*k+l)*numberFactors+i) = primeResidues[r+k];
				}
			}
		}
		r+=numbersPrimeResidues[i];
	}
	residues = (unsigned int *) malloc(*numberResidues * sizeof(int));
	for (i=0; i<*numberResidues; i++) {
		residues[i] = CRT(&numberFactors, listCRT+numberFactors*i, factors, C);
	}
	qsort(residues, *numberResidues, sizeof(int), cmpfnc);

	free(numbersPrimeResidues);
	free(primeResidues);
	free(listCRT);
	return residues;
}

//C<size
unsigned long long *checkMod (short *smoothNumbers, unsigned int *numberResidues, unsigned int *residues, unsigned long long *start, unsigned int *size, short *numberRoots, short *roots, unsigned int *C, unsigned int *numberSmoothIntsModC) {
	
	unsigned int *values = (unsigned int *) calloc(*size, sizeof(int));
	unsigned long long *smoothIntsModC;
	unsigned int startModC = *start % *C;
	unsigned int i;
	long j;
	unsigned int k;
	short maxRoot = 0;
	short smooth;
	for (i=1; i<*numberRoots; i++) {
		if (roots[i]>maxRoot) {
			maxRoot = roots[i];
		}
	}
	*numberSmoothIntsModC=0;
	for (i=0; i<*numberResidues; i++) {
		j = (long)residues[i]-startModC;
		while (j<maxRoot) {
			j+=*C;
		}
		while (j<*size) {
			if (smoothNumbers[j]==1) {
				smooth=1;
				for (k=1; k<*numberRoots; k++) {
					if (smoothNumbers[j-roots[k]] == 0) {
						smooth=0;
						break;
					}
				}
				if (smooth ==1) {
					values[*numberSmoothIntsModC]=j;
					(*numberSmoothIntsModC)++;
					printf("smooth int mod C: %llu\n", *start+j);
				}
			}
			j+=*C;
		}
	}
	smoothIntsModC = (unsigned long long *) malloc(*numberSmoothIntsModC * sizeof(long long));
	for (i=0; i<*numberSmoothIntsModC; i++) {
		smoothIntsModC[i] = values[i]+*start;
	}
	free(values);
	return smoothIntsModC;
}

//C>=size
//relevant steps to cover size
unsigned int findRelevantSteps(unsigned int *numberResidues, unsigned int *residues, unsigned int *size, unsigned int *C) {

	unsigned int relevantSteps =1;
	unsigned int i = 0;

	while ( i<*numberResidues && relevantSteps+i<*numberResidues) {
		if (residues[i+relevantSteps]-residues[i]<*size) {
			relevantSteps++;
			if (relevantSteps == *numberResidues) {
				return *numberResidues;
			}
		}else{
			i++;
		}
	}
	while (i<*numberResidues) {
		if (residues[(i+relevantSteps)%*numberResidues]+*C-residues[i]<*size) {
			relevantSteps++;
			if (relevantSteps == *numberResidues) {
				return *numberResidues;
			}
		}else{
			i++;
		}
	}

	return relevantSteps;
}

//checkMOD
unsigned long long *checkMOD(short *smoothNumbers, unsigned int *numberResidues, unsigned int *residues, unsigned long long *start, unsigned int *size, short *numberRoots, short *roots, unsigned int *C, unsigned int *relevantSteps, unsigned int *numberSmoothIntsModC) {

	unsigned int *values = (unsigned int *) calloc(*size, sizeof(int));
	unsigned long long *smoothIntsModC;
	unsigned int startModC = *start % *C;
	unsigned int i;
	long j;
	unsigned int k;
	short maxRoot = 0;
	short smooth;
	unsigned int searchL = 0;
	unsigned int searchR = *numberResidues;
	unsigned int searchPivot = floor((double)*numberResidues/2);
	unsigned int lastResidue;

	for (i=1; i<*numberRoots; i++) {
		if (roots[i]>maxRoot) {
			maxRoot = roots[i];
		}
	}
	*numberSmoothIntsModC=0;
	while (searchR-searchL>0) {
		if (startModC>residues[searchPivot]) {
			searchL=searchPivot+1;
		}else{
			searchR=searchPivot;
		}
		searchPivot=floor((double)(searchL+searchR)/2);
	}
	lastResidue=searchPivot+*relevantSteps;
	if (lastResidue>*numberResidues) {
		for (i=0; i<(lastResidue % *numberResidues); i++) {
			j=residues[i]-startModC+*C;
			if (j<*size && maxRoot<=j) {
				if (smoothNumbers[j]==1) {
					smooth=1;
					for (k=1; k<*numberRoots; k++) {
						if (smoothNumbers[j-roots[k]] == 0) {
							smooth=0;
							break;
						}
					}
					if (smooth ==1) {
						values[*numberSmoothIntsModC]=j;
						(*numberSmoothIntsModC)++;
						printf("smooth int mod C: %llu\n", *start+j);
					}
				}
			}
		}
	}
	if (*numberResidues < lastResidue) {
		lastResidue = *numberResidues;
	}
	for (i = searchPivot; i<lastResidue; i++) {
		j=residues[i]-startModC;
		if (j<*size && maxRoot<=j) {
			if (smoothNumbers[j]==1) {
				smooth=1;
				for (k=1; k<*numberRoots; k++) {
					if (smoothNumbers[j-roots[k]] == 0) {
						smooth=0;
						break;
					}
				}
				if (smooth ==1) {
					values[*numberSmoothIntsModC]=j;
					(*numberSmoothIntsModC)++;
					printf("smooth int mod C: %llu\n", *start+j);
				}
			}
		}
	}
	smoothIntsModC = (unsigned long long *) malloc(*numberSmoothIntsModC * sizeof(long long));
	for (i=0; i<*numberSmoothIntsModC; i++) {
		smoothIntsModC[i] = values[i]+*start;
	}

	free(values);
	return smoothIntsModC;
}



int main() {
	
	//general parameters
	unsigned int smoothnessBound = pow(2,16);
//	unsigned long long start = pow(2,40);
	unsigned int size = pow(2,20);

/*	//specific parameters1
	short numberRoots = 9;
	short roots[9] = {0, 1, 3, 5, 8, 11, 13, 15, 16};
	short deg = 6;
	short poly[6] = {0, 3, 5, 11, 13, 16};
//	short poly[6] = {1, 1, 8, 8, 15, 15};
	unsigned int C = 14400;
	unsigned long long start = 5170314000000;
//	unsigned long long start = 6781477000000;
//	unsigned long long start = 9244655000000;
//	unsigned long long start = 19052682000000;
*/
/*	//specific parameters2
	short numberRoots = 9;
	short roots[9] = {0, 2, 7, 8, 15, 22, 23, 28, 30};
	short deg = 6;
	short poly[6] = {0, 7, 8, 22, 23, 30};
//	short poly[6] = {2, 2, 15, 15, 28, 28};
	unsigned int C = 705600;
	unsigned long long start = 22687888000000;
//	unsigned long long start = 26042586000000;
*/
/*	//specific parameters3
	short numberRoots = 9;
	short roots[9] = {0, 2, 5, 16, 21, 26, 37, 40, 42};
	short deg = 6;
	short poly[6] = {0, 5, 16, 26, 37, 42};
//	short poly[6] = {2, 2, 21, 21, 40, 40};
	unsigned int C = 2822400;
	unsigned long long start = 18675743000000;
//	unsigned long long start = 36144284000000;
*/
/*	//specific parameters4
	short numberRoots = 9;
	short roots[9] = {0, 3, 7, 33, 40, 47, 73, 77, 80};
	short deg = 6;
	short poly[6] = {0, 7, 33, 47, 73, 80};
//	short poly[6] = {3, 3, 40, 40, 77, 77};
	unsigned int C = 85377600;
	unsigned long long start = 19798693000000;
//	unsigned long long start = 32519458000000;
*/
/*	//specific parameters5
	short numberRoots = 9;
	short roots[9] = {0, 4, 11, 24, 35, 46, 59, 66, 70};
	short deg = 6;
	short poly[6] = {0, 11, 24, 46, 59, 70};
//	short poly[6] = {4, 4, 35, 35, 66, 66};
	unsigned int C = 85377600;
	unsigned long long start = 24924102000000;
*/
/*	//specific parameters6
	short numberRoots = 14;
	short roots[14] = {0, 1, 11, 18, 19, 30, 39, 50 ,56, 68 ,70, 79, 81, 84};
	short deg = 7;
	short poly[7] = {0, 18, 19, 50, 56, 79, 81};
//	short poly[7] = {1, 11, 30, 39, 68, 70, 84};
	unsigned int C=5145940800;	//CAUTION: integer overflow, but allowing a long could cause overflows elswere. Wait for 128bit variables.
	unsigned long long start = pow(2,40);
*/
	//specific parameters 7
	short numberRoots = 16;
	short roots[16] = {0, 1, 2, 4, 9, 11, 20, 23, 27, 30, 39, 41, 46, 48, 49, 50};
	short deg = 8;
	short poly[8] = {0, 4, 9, 23, 27, 41, 46, 50};
//	short poly[8] = {1, 2, 11, 20 ,30, 39, 48, 49};
	unsigned int C=1210809600;
	unsigned long long start = pow(2,35);
	
//variables
	unsigned int numberSmoothPrimes;
	unsigned int *smoothPrimes;
	unsigned int *maxExponents;
	unsigned int numberSmoothNumbers;
	short *smoothNumbers;
	unsigned int numberSmoothIntsModC;
	unsigned long long *smoothIntsModC;
	unsigned int numberResidues;
	unsigned int *residues;
	unsigned int relevantSteps;

//timing
	clock_t initialNew,initialPaper;
	clock_t finalNew,finalPaper;

	smoothPrimes = findSmoothPrimes(&smoothnessBound, &numberSmoothPrimes);
	maxExponents = findMaxExponents(&smoothnessBound, &numberSmoothPrimes, smoothPrimes);
	smoothNumbers = findSmoothNumbers(&numberSmoothPrimes, smoothPrimes, maxExponents, &start, &size, &numberSmoothNumbers);

	initialPaper = clock();
	smoothIntsModC = findSmoothIntsModC(&start, &size, smoothNumbers, &numberRoots, roots, &deg, poly, &C, &numberSmoothIntsModC);
	finalPaper = clock();

	free(smoothIntsModC);

	residues = findResidues(&numberSmoothPrimes, smoothPrimes, &deg, poly, &C, &numberResidues);
	relevantSteps = findRelevantSteps(&numberResidues, residues, &size, &C);

	initialNew = clock();
	if (size<C) {
		smoothIntsModC = checkMOD(smoothNumbers, &numberResidues, residues, &start, &size, &numberRoots, roots, &C, &relevantSteps, &numberSmoothIntsModC);     
	}else{
		smoothIntsModC = checkMod(smoothNumbers, &numberResidues, residues, &start, &size, &numberRoots, roots, &C, &numberSmoothIntsModC);
	}
	finalNew = clock();

	printf("duration Paper: %f\nduration New: %f\n",(double)(finalPaper-initialPaper)/CLOCKS_PER_SEC,(double)(finalNew-initialNew)/CLOCKS_PER_SEC);

	double log2=log(2);
	printf("sBound: %.2f, start: %.2f, size: %.2f\n", log(smoothnessBound)/log2, log(start)/log2, log(size)/log2);
	printf("deg: %d, C: %u\n", deg, C);

	printf("sp: %u", numberSmoothPrimes);
	printf(", ex: 2: %u, last: %u", maxExponents[0], maxExponents[numberSmoothPrimes-1]);
	printf(", sn: %u\n", numberSmoothNumbers);
	printf("res: %u", numberResidues);
	printf(", relSteps: %u\n", relevantSteps);
	printf("simc: %u\n", numberSmoothIntsModC);

	free(smoothPrimes);
	free(maxExponents);
	free(smoothNumbers);
	free(residues);
	free(smoothIntsModC);
	return 0;
}

//logSieve
