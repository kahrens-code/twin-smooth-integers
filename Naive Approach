#naive approach to find twin smooth integers

#smoothList is a list of tupels (integer,smoothness) where smoothness is "1" if integer is smooth and "0" otherwise
#roots is a list of all elements in the PTE solution or equivalentely all zeros of both of the corresponding polynomials
#polyA is one of the two polynomials corresponding to the PTE solution
#diffC is the difference C=|a(x)-b(x)| between the two polynomials corresponding to the PTE solution
#the output is a list of integers l for which a(l)/C and b(l)/C are twin smooth integers

def checkAll(smoothList,roots,polyA,diffC): 
    values=[];
    for i in range(max(roots),len(smoothList)):             #to prevent i-roots[r]<0 start at max(roots)
        if smoothList[i][1]==1:                             #check if smoothList[i][0] is smooth
            for r in range(1,len(roots)):                   #roots[0] is 0 (already checked)
                if smoothList[i-roots[r]][1]==0: break;     #check if all factors of polyA(smoothList[i][1]) are smooth
            else:                                           #if there was no "break" continue
                if ZZ(polyA(smoothList[i][0]))%diffC==0:    #check if polyA(smoothList[i][1])/C is an integer
                    values.append(smoothList[i][0]);
    return(values)
