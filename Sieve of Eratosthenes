#find the set of primes smaller than the bound and the maximal exponent for powersmoothness for each prime
def smoothPrimes(smoothBound): 
    array=[];
    for p in range(smoothBound):
        if p in Primes():
            maxExponent=1;
            while p^(maxExponent+1)<smoothBound: maxExponent=maxExponent+1;
            array.append((p,maxExponent));
    return(array)

#sieve for "smooth" integers in the interval [start,start+size)
#the "smoothness" is given by the list "factors" of tupes (prime factor,maximal exponent) and thus can be smooth, power-smooth or arbitrary
#the output is a list of tuples (integer,smoothness) where smoothness is "1" if the integer is "smooth" and "0" otherwise
def sieve(start,size,factors):  
    array=[[start+i,1] for i in range(size)];
    for f in factors:
        p=f[0];
        for exponent in range(f[1]):  
            q=p^(exponent+1);  
            step=-start%q;
            while step<size:  
                array[step][1]=array[step][1]*p;  
                step=step+q;
    for a in array: 
        if a[0]==a[1]:  
            a[1]=1;  
        else: a[1]=0;  
    return array

#example: find all power-smooth integers in the interval [2^40,2^40+2^20)
fac16=smoothPrimes(2^16);
sieve40=sieve(2^40,2^20,fac16);
